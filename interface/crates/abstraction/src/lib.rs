//! Contains the general abstraction traits for interfacing with the C++ template types.
//!
//! ## `ParsingRulesDecl`
//!
//! This is used to define the rules associated with a type for parsing (and enum variants).
//!
//! ## `FromCppTypes`
//!
//! This actually parses an output of the grammar as a type safe structure by parsing the
//! individual components. While doing so the rule of the main component will be enforced to be one
//! of the rules declared in the previous trait.
//!
//! ## `ToCppTypes`
//!
//! This converts a type safe structure into a string that can be understood by the C++ compiler as
//! a template type expression.
//!
//! ## Parameters
//!
//! All traits are generic over the rule type generated by the grammar. This way they can
//! implemented on foreign types in other crates.
//!
//! ## Monads
//!
//! Where useful the traits are implemented on [`Option`] and [`Result`] so that other types can use
//! them as components. Additionally macros are defined to construct the needed implementations for
//! i. e. [`Result`]
//!
//! Because of the PEG grammar ([pest] crate) generic rules are not possible.
//! Because of that `Option<T>` needs to be implemented as a silent
//! `OptionT` rule and a non-silent `SomeT` rule for every `T` (`None` can be shared).
//! Also `Result<T, E>` can't be implemented in an easy way, but with a macro special
//! implementations can be added per `T`, `E` combination.

mod main_rule;
mod opt;
mod res;

use itertools::Itertools;

use pest::iterators::Pair;
use pest::RuleType;

pub trait ParsingRulesDecl<R: RuleType + 'static> {
    fn _const_parses() -> impl Iterator<Item = R>;
    fn _const_main_rule() -> R;
}

pub trait FromCppTypes<R: RuleType + 'static>: ParsingRulesDecl<R> {
    fn _try_from_cpp(p: Pair<'_, R>) -> Option<Self>
    where
        Self: Sized;

    fn try_from_cpp(p: Pair<'_, R>) -> Option<Self>
    where
        Self: Sized,
    {
        <Self as ParsingRulesDecl<R>>::_const_parses()
            .contains(&p.as_rule())
            .then_some(())?;
        Self::_try_from_cpp(p)
    }
}

/// Types that implement this trait can be converted into a template type string that the
/// C++-compiler can parse
///
/// Even though the Rule type is rarely needed for this implementation it is added as generic so
/// that instances are no foreign traits and they can get implemented on foreign types
///
/// For 'standard' types the associated derive macro can be used
pub trait ToCppTypes<R: RuleType + 'static> {
    fn to_cpp_types(&self) -> String;
}

impl<R: RuleType + 'static, T: ToCppTypes<R>> ToCppTypes<R> for Vec<T> {
    fn to_cpp_types(&self) -> String {
        self.iter().map(|a| a.to_cpp_types()).join(", ")
    }
}

/// Trait that indicates that a given type `T` has equivalent `Option<T>`, `Some<T>` and `None` in the used grammar
pub trait CanBeSome<R: RuleType + 'static> {
    const OPTION_RULE: R;
    const SOME_RULE: R;
    const NONE_RULE: R;
}
/// Trait that indicates that a given type `T` has equivalent to `Ok<T>` in the used grammar
pub trait CanBeOk<R: RuleType + 'static> {
    const OK_RULE: R;
}
/// Trait that indicates that a given type `T` has equivalent to `Err<T>` in the used grammar
pub trait CanBeErr<R: RuleType + 'static> {
    const ERR_RULE: R;
}
/// Trait that indicates that a given type `T` has equivalent to `Result<T, E>` in the used grammar
pub trait FormsOkOfResult<R: RuleType + 'static, E: CanBeErr<R>> {
    const RESULT_RULE: R;
}

pub mod _deps {
    #[cfg(feature = "paste")]
    pub use paste::paste;
}
